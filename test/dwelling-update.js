'use strict'

// tests for dwelling-update
// Generated by serverless-mocha-plugin
const AWS = require('aws-sdk')
const Promise = require('bluebird')
const request = require('request')
const mochaPlugin = require('serverless-mocha-plugin')
const util = require('./util')

// set AWS credentials because the test cases are invoked from local context
let credentials = new AWS.SharedIniFileCredentials({profile: 'hopo'})
AWS.config.credentials = credentials

const expect = mochaPlugin.chai.expect
let wrapped = mochaPlugin.getWrapper('dwelling-update', '/functions/dwelling/update/update.js', 'index')

const username = 'steven'
const password = 'AAAaaa$$$000'
const dwellingName = 'name-' + String(new Date().getTime())
const dwellingType = 'type-' + String(new Date().getTime())

describe('dwelling-update', () => {
  // pre-processor: clear existing dwelling for current user
  before((done) => {
    done()
  })
  
  beforeEach((done) => {
    request(util.getLoginPayload(username, password), function (error1, response1, body1) {
      global.idToken = JSON.parse(body1).idToken
      request(util.getClearUserDataPayload(global.idToken), function (error2, response2, body2) {
        done()
      })
    })
  })

  // case1: update-success
  it('should update a dwelling', () => {
    return new Promise(function (resolve, reject) {
      let data = {
        dwellingName: dwellingName,
        dwellingType: dwellingType
      }

      request(util.getCreateDwellingPayload(global.idToken, data), function (error, response, body) {
        resolve(JSON.parse(body).dwellingId)
      })
    })
    .then(function (dwellingId) {
      let newDwellingName = dwellingName + '-new'
      let newDwellingType = dwellingType + '-new'

      let pathParameters = {
        dwelling_id: dwellingId
      }
      let data = {
        dwellingName: newDwellingName,
        dwellingType: newDwellingType
      }

      return wrapped.run(util.updateEvent(username, pathParameters, data)).then((response) => {
        // status code is 200
        expect(response).to.have.property('statusCode', 200)

        // dwelling is updated with correct values
        let body = JSON.parse(response.body)
        expect(body).to.be.an.object
        expect(body).to.have.property('dwellingId', dwellingId)
        expect(body).to.have.property('identityId', username)
        expect(body).to.have.property('dwellingName', newDwellingName)
        expect(body).to.have.property('dwellingType', newDwellingType)
      })
    })
  })

  // case2: update-fail-missing-field
  it('should NOT update a dwelling due to missing field', () => {
    return new Promise(function (resolve, reject) {
      let data = {
        dwellingName: dwellingName,
        dwellingType: dwellingType
      }

      request(util.getCreateDwellingPayload(global.idToken, data), function (error, response, body) {
        resolve(JSON.parse(body).dwellingId)
      })
    })
    .then(function (dwellingId) {
      let pathParameters = {
        dwelling_id: dwellingId
      }
      let data = {}

      return wrapped.run(util.updateEvent(username, pathParameters, data)).then((response) => {
        // status code is 422
        expect(response).to.have.property('statusCode', 422)

        // error message is returned
        let body = JSON.parse(response.body)
        expect(body).to.be.an.object
        expect(body.code).to.include(422)
        expect(body.message).to.not.eql(null)
      })
    })
  })

  // case3: update-fail-not-found
  it('should NOT update a dwelling due to dwellingId not found', () => {
    let pathParameters = {
      dwelling_id: 'invalid_dwelling_id'
    }
    let data = {
      dwellingName: dwellingName + '-new',
      dwellingType: dwellingType + '-new'
    }

    return wrapped.run(util.updateEvent(username, pathParameters, data)).then((response) => {
      // status code is 404
      expect(response).to.have.property('statusCode', 404)

      // error message is returned
      let body = JSON.parse(response.body)
      expect(body).to.be.an.object
      expect(body.code).to.include(404)
      expect(body.message).to.not.eql(null)
    })
  })

  // case4: update-fail-wrong-user
  it('should NOT update a dwelling due to dwelling belongs to another user', () => {
    return new Promise(function (resolve, reject) {
      let data = {
        dwellingName: dwellingName,
        dwellingType: dwellingType
      }

      request(util.getCreateDwellingPayload(global.idToken, data), function (error, response, body) {
        resolve(JSON.parse(body).dwellingId)
      })
    })
    .then(function (dwellingId) {
      let pathParameters = {
        dwelling_id: dwellingId
      }
      let data = {
        dwellingName: dwellingName + '-new',
        dwellingType: dwellingType + '-new'
      }
      let anotherUsername = 'lujin'

      return wrapped.run(util.updateEvent(anotherUsername, pathParameters, data)).then((response) => {
        // status code is 404
        expect(response).to.have.property('statusCode', 404)

        // error message is returned
        let body = JSON.parse(response.body)
        expect(body).to.be.an.object
        expect(body.code).to.include(404)
        expect(body.message).to.not.eql(null)
      })
    })
  })
})
